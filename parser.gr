module Parser

from "./examples.gr" include Examples
from "./tokenise.gr" include Tokenise
from "result" include Result
from "list" include List

provide enum rec Data {
  Symbol(String),
  TaggedList(Data, List<Data>),
}

let rec parseOne = (in: List<String>, out: List<Data>) =>
  match ((in, out)) {
    (["(", ...restIn], [lastOut, ...restOut]) => {
      match (parseOne(restIn, [])) {
        Ok((unparsed, nextIn)) =>
          parseOne(
            unparsed,
            List.append([TaggedList(lastOut, nextIn)], restOut)
          ),
        Err(reason) => Err(reason),
      }
    },
    ([")", ...restIn], out) => Ok((restIn, List.reverse(out))),
    ([nextIn, ...restIn], out) =>
      parseOne(restIn, List.append([Symbol(nextIn)], out)),
    ([], out) => Ok(([], List.reverse(out))),
  }: Result<(List<String>, List<Data>), String>

provide let parse = tokens => match (parseOne(tokens, [])) {
  Ok(([], data)) => Ok(data),
  Ok(([_, ..._], _)) => Err("Didn't consume all input tokens"),
  Ok(_) => Err("Unexpected error"),
  Err(reason) => Err(reason),
}

let tokeniseAndParse = example => parse(Tokenise.tokenise(example))

let expectedCompare = Ok(
  [
    TaggedList(
      Symbol("eq?"),
      [
        Symbol("second"),
        TaggedList(
          Symbol("first"),
          [
            TaggedList(
              Symbol("rest"),
              [
                TaggedList(
                  Symbol("pair"),
                  [
                    TaggedList(Symbol("Quote"), [Symbol("first")]),
                    TaggedList(
                      Symbol("pair"),
                      [
                        TaggedList(Symbol("Quote"), [Symbol("second")]),
                        Symbol("end"),
                      ],
                    ),
                  ],
                ),
              ],
            ),
          ],
        ),
      ],
    ),
  ],
)

let expectedAssignment = Ok(
  [
    TaggedList(
      Symbol("Name"),
      [
        Symbol("data"),
        TaggedList(
          Symbol("pair"),
          [
            TaggedList(Symbol("Quote"), [Symbol("one")]),
            TaggedList(
              Symbol("pair"),
              [TaggedList(Symbol("Quote"), [Symbol("two")]), Symbol("end")],
            ),
          ],
        ),
      ],
    ),
    TaggedList(
      Symbol("Name"),
      [Symbol("expected"), TaggedList(Symbol("Quote"), [Symbol("two")])],
    ),
    TaggedList(
      Symbol("Name"),
      [
        Symbol("actual"),
        TaggedList(
          Symbol("first"),
          [TaggedList(Symbol("rest"), [Symbol("data")])],
        ),
      ],
    ),
    TaggedList(Symbol("eq?"), [Symbol("expected"), Symbol("actual")]),
  ],
)

provide let test = () =>
  Ok([Symbol("foo")]) == tokeniseAndParse(Examples.symbol) &&
    Ok([Symbol("foo"), Symbol("bar")]) == tokeniseAndParse(Examples.twoSymbols) &&
    Ok([TaggedList(Symbol("Quote"), [Symbol("foo")])]) ==
      tokeniseAndParse(Examples.quote) &&
    Ok(
      [
        TaggedList(
          Symbol("Quote"),
          [TaggedList(Symbol("Quote"), [Symbol("foo")])],
        ),
      ],
    ) ==
      tokeniseAndParse(Examples.nestedQuote) &&
    expectedCompare == tokeniseAndParse(Examples.compare) &&
    expectedAssignment == tokeniseAndParse(Examples.assignment)
